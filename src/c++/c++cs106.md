# *c++深入学习记录*
//你喜欢某个方向也许是因为你了解某个方向,只有了解完所有的方向再进行选择你才能说你喜欢这个方向

内联函数
---
- ifndef,endif:
>头文件防止重复引用
- 当文件名为引号时，预处理器将在当前目录中查找（自己定义的头文件）
- #define TOTAL_MARGIN (LEFT_MARGIN * SCALE + RIGHT_MARGIN * SCALE)
- typedef

>枚举

宏定义
--
- 注意区分
>#define MANXSIZE 35    //这是定义了一个常量
>#define park a         //这是把a替换成park
>宏定义大致分为两类,对于#define A B,一类是把A的值定义为B(对象宏),另一类为在B出现的地方把B替换为A(函数宏)
- 防止重复定义(条件编译)   //macro：宏指令
>// structs.h
>#ifndef STRUCTS_H
>#define STRUCTS_H
>struct MyStruct {
  int x;
  int y;
};
>#endif // STRUCTS_H
- 函数宏
>#define PLUS_ONE(x) ((x) + 1)
>int x = PLUS_ONE(137);
>其他例子:
>#define MAKE_FUNCTION(fnName) void fnName()
>MAKE_FUNCTION(MyFunction) {
 cout << "This is a function!" << endl;
 }
 结果:
 void MyFunction() {
 cout << "This is a function!" << endl;
 }//把fnName想象为x(或者一个占位符),替换到后面的fnName
 - 定义字符串常量
 >#define ERROR_MESSAGE "An error occurred"
- 定义条件表达式
>#define MAX(a, b) ((a) > (b) ? (a) : (b))
-取消宏定义
>#define MY_INT 137
 int x = MY_INT; // MY_INT is replaced
 #undef MY_INT;
 int MY_INT = 42; // MY_INT not replaced
内联函数
--
- 相当于在预处理过程帮你把函数定义补上去,用于减少调用,缺点是增加内存.一般用于调用频繁的函数

继承和派生
==
- class PartTimeWorker : public Person{}
- class NoDerived final { }; //final防止被继承
-       a           b               c       d
访问位置 该类成员函数 派生类成员函数 该类友元 该类对象
public : 可以被 a、b、c 和 d 访问。
protected : 可以被 a、b 和 c 访问。
private: 可以被 a 和 c 访问。
- public 继承: 基类的 protected 和 public 属性在其派生类中保持不变。
protected 继承: 基类的 protected 和 public 属性在派生类中变为 protected。
private 继承: 基类的 protected 和 public 属性在派生类中变为 private。
>- 公有继承（Public Inheritance）：
语法：class DerivedClass : public BaseClass
特点：派生类从基类继承的成员在派生类内部仍然保持公有的访问权限。派生类对象可以访问基类的公有成员，但不能直接访问基类的私有成员。
>- 私有继承（Private Inheritance）：
语法：class DerivedClass : private BaseClass
特点：派生类从基类继承的成员在派生类内部变为私有成员。派生类对象无法直接访问基类的成员，但可以通过派生类的成员函数间接访问基类的成员。
>- 保护继承（Protected Inheritance）：
语法：class DerivedClass : protected BaseClass
特点：派生类从基类继承的成员在派生类内部变为受保护的成员。派生类对象无法直接访问基类的成员，但可以通过派生类的成员函数间接访问基类的成员。同时，派生类的子类也可以访问基类的成员。
>- 虚拟继承（Virtual Inheritance）：
语法：class DerivedClass : virtual public BaseClass
特点：虚拟继承主要用于解决多重继承中的菱形继承问题。它确保在继承链中只存在一个共享基类对象的实例。在虚拟继承中，派生类对共享基类的访问是间接的，需要通过基类的指针或引用进行访问。

构造函数和析构函数  //都可以重载
---
>析构函数在对象销毁时执行一系列清理任务，例如关闭文件、释放动态分配的内存、释放资源等。在析构函数中可以执行任何必要的操作，以确保对象的资源得到适当的释放和清理。

>需要释放的资源
>- 动态分配的内存：如果在对象的构造函数中使用了动态内存分配运算符new，那么在析构函数中应该使用相应的delete或delete[]运算符释放这些内存，以防止内存泄漏。
>- 打开的文件或流：如果在对象的构造函数中打开了文件、创建了流或建立了其他类型的资源连接，那么在析构函数中应该关闭文件、释放流或断开资源连接，以避免资源泄漏。
>- 分配的系统资源：如果对象分配了其他类型的系统资源，例如锁、句柄或网络连接，那么在析构函数中应该释放这些资源，以保持系统资源的正确管理。
>- 被对象所管理的其他对象：如果对象拥有其他对象的所有权，即对象负责管理其他对象的生命周期，那么在析构函数中应该释放这些被管理的对象。

---------
- 静态类型      
指对象声明时的类型或表达式生成时的类型，在编译时就已经确定，例如：
class Base { }
Base *p; //指针p的静态类型为Base
或者:
void print(int num) {cout << "Integer: " << num << endl;}
void print(float num) {cout << "Float: " << num << endl;}
- 动态类型  //理解为对象中出现?
指指针或引用所绑定的对象的类型，仅在运行时可知，例如：
class Derived : public Base { };
Derived d; //非指针或引用，动态类型与静态类型相同
Base *p = &d; //指针p的动态类型为Derived
--------
>构造函数

>虚函数
>- 运行时多态性（Runtime Polymorphism）:

>#include <iostream>
using namespace std;
class B0 //基类B0声明
{
public:
 void display(){cout<<"B0::display()"<<endl;} //公有成员函数
};
class B1: public B0 
{
 public:
  void display(){cout<<"B1::display()"<<endl;} 
};
void fun(B0 *ptr) 
{
 ptr->display(); //"对象指针->成员名"  
}
int  main() //主函数
{ 
B0 b0; //声明B0类对象
 B1 b1; //声明B1类对象
 B0 *p; //声明**B0类指针**
 p=&b0; //B0类指针指向B0类对象
 fun(p);
 p=&b1; //B0类指针指向B1类对象
 fun(p);
 fun(p);//结果一样，说明用指针调用的都是基类的函数，如果在B0的display 函数前加上virtual，结果不一样。
}
