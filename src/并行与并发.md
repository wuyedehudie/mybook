
## 进程和线程
- 不同进程有自己的内存空间（页表），文件描述符，系统资源；进程之间通信需要显示ipc机制（进程通信机制）；进程启动时需要分配资源和内存空间；
- 线程共享同一进程的内存空间，创建和切换线程的开销小；线程共享内存会带来危险

##

## 消息队列
- MQ（全称Message Queue）是一种进程间通信或同一进程的不同线程间的通信方式，队列就是一个消息容器
- IPC(进程间通信)
- 消息队列(在进程之间)相关库：ZeroMQ（轻量级, 适用通信密集型)，boost.Interprocess(), Apache Kalfka（流处理应用程序），RabbitMQ消息代理，实现AMQP标准，
- 中间件(Middleware), 位于客户端和服务端之间的软件层或服务
- 远程过程调用(RPC)

```
class background_task{}
std:thread my_thread(background_task（）);
```
相当于创建一个返回值std::thread类型的函数，参数是background_task



并行（Parallelism）：
指的是在同一时刻执行多个任务或操作。这可以在多个处理单元（例如多个 CPU 核心或多台计算机）上同时进行，每个处理单元独立执行不同的指令或任务。

并发（Concurrency）：
指的是在相同时间段内处理多个任务，这些任务可能在不同的时间点执行，但在一段时间内可能存在多个任务正在执行。
并发通常用于处理多个任务之间的交替执行和共享资源，它使得在单个处理器上似乎同时执行多个任务。

创建线程五种方式
- std::thread
- 用posix线程库(phread)
- Lambda (用thread)
- 使用函数对象+thread
-  std::for_each

- 线程分离：如果主线程创建的子线程是分离的，主线程结束时不会等待子线程完成并且结束进程。对于非分离的子线程主线程会在子线程结束后等待子线程结束才结束进程

实战
---
- 重载运算符operator+()
- 创建线程

## 八股
 sleep(0)，让线程主动放弃cpu时间,让资源可以分配给其他相同优先级的线程，避免长时间占用资源
 如果 std::thread 对象销毁之前还没有做出决定，程序就会终止( std::thread 的析构函数会调用 std::terminate() )

## 函数
```
func(){...}
std::thread t(func)
t.detach()
t.join()        //阻塞主线程，需要等待子线程结束主线程才能结束
t.getid
std::this_thread::
```
- 传递参数
创建子线程时传入对象参数是传递引用, std:move可以转移资源但原线程的对象会被销毁，
智能指针传递对象，保证线程安全；
子线程和主线程共享的资源；全局遍历

转移线程所有权，当thread1有一个thread的时候，不能使用移动语义赋值线程
移动敏感的容器，指常常需要移动语义提高性能的容器如vector

## 对象和变量
```std::thread```
```std::mutex```互斥锁（Mutex）可以确保在锁定（上锁）到解锁的过程中，被锁保护的临界区内的代码不会被其他线程同时执行, 临界区简单而言是上锁到解锁过程中的所执行的语句，这里面涉及到的变量不会被其他线程修改
```hire_mutex```
```std::recursive_mutex```      
```std::scoped_lock<std::mutex> lock(mutex1,mutex2)```同时锁多个锁
```std::lock_guard<std::mutex>  guard(mutex) ```离开作用域时自动释放锁

#### 原子变量
```std::atomic<int> a``` std::atomic 的底层实现通常依赖于硬件提供的原子指令。在现代处理器中，通常会提供一些原子指令，比如 CAS（Compare and Swap）等，用于实现原子操作，不会被其他线程中断。
**相关函数:**  std::atomic<T>::store() 赋值操作，使用直接a.store(value), 保证其他线程不会看到修改只修改部分时
参数: memory_order_consume memory_order_acquire memory_order_seq_cst memory_order_release

## 函数
```
//线程
thread::hardware_concurren(), 返回支持并发线程的数量，可以是CPU核芯数量
thread::get_id()，如果thread对象没有和任一线程关联，返回std::thread::type，
在对象内部使用std::this_thread::get_id() 
```

## 问题
死锁：各自都要用两个互斥量的两个线程，但刚好各自锁了一个锁，都在等另一个锁被释放，因此两个线程都停了下来：
解决：1.两个锁要按照顺序锁上
2,互相调用join()；

## pthread
```
pthread_t tid
pthread_create(&tid,attr,start_routine,arg)
```
pthread是指向pthread_t类型的指针；attr指向pthreard_attr_t类型指针，可以是NULL；start_routing是函数指针，arg是参数
```pthread_cond_t```条件变量
```pthread_cond_timedwait(cond,mutex,abstime)``` 设置一个超时事件，如果条件变量超时前未满足，线程将返回
### sem
相当于一个int
```int sem_init(sem_t *sem, int pshared, unsigned int value);```初始化信号量，需要先声明一个指向信号量的指针，value是自己设置的初始值
```int sem_destroy(sem_t *sem);```销毁信号量
```int sem_wait(sem_t *sem);```信号量值减一，如果小于0则阻塞线程
```int sem_post(sem_t *sem);```信号量的值加一，唤醒等待该信号量的线程
```int sem_trywait(sem_t *sem);```尝试对信号量的值减一，如果值为零则不阻塞线程，直接返回失败
```int sem_timedwait(sem_t *sem, const struct timespec *abs_timeout);```在指定的超时事件内等待信号量的值减1
```int pthread_cancel(pthread_t thread);```pthread_cancel 取消线程可能会导致资源泄漏和程序状态不一致等问题，因此在实际应用中需要慎重使用，并且要确保被取消的线程能够正确地释放资源和清理状态。
### pthread_lock 
```pthread_setname_np(pthread_self())```
```pthread_ ```

```pthread_lock_t``` 普通锁
```pthread_rw_lock```读写锁

操作读写锁：
```pthread_rwlock_init(&mutex)```
```pthread_rwlock_rdlock(&mutex)```
```pthread_rwlock_wrlock(&mutex)```
```pthread_rwlock_destory(&mutex)```


pthread实现一个读写锁模板





