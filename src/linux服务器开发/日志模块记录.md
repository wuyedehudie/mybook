总结和回顾
====
- LogFormatter负责解析格式（在Logger中获取需要格式）,调用FormatterItem的函数最终输出
- LogEvent负责存储日志内容，内容由用户在程序中调用LogEvent构造函数来创造日志内容
- log()函数负责输出，logger的log最终要调用成员函数m_appender的log,m_appender的log负责输出到对应的地方，而m_appender的log最终会用FormatItem的format获取到日志内容的流，然后输出
坑：注意宏定义后面需不需要分号";"

后续优化
----
删除不需要的成员变量


过程中的新的知识和c++基础
======

- ~virtual LogAppender(){}
虚析构函数通常用于当基类的指针指向派生类的对象时，确保在销毁对象时调用正确的析构函数

elapse

1.日志模块:成员变量,智能指针,虚析构函数
2.实现Logger
3.Formatter,以及formatItem,有些日志输出不需要某些部分，有些需要某部分,需要选择性输出，所以分了好几个Item

- 考虑内存对齐，高性能场景,int,unsigned int,float是4字节，double
- LogFormatter::ptr getFormatter() **const** { return m_formatter };//当返回值是引用时，可以防止修改引用
- 函数重载的另一种形式
  	void Logger::debug(LogEvent::ptr event) {
		debug(LogLevel::DEBUG, event);
	}
- 	return !!m_filestream;//!m_filestream表示将文件流是否成功打开转为布尔值(文件流有效返回false，无效返回true)，还有一个感叹号则将布尔值取非，总的句子意思是文件流有效则返回true
- virtual std::string format(LogEvent::ptr event) = 0;//=0表示纯虚函数，只能被继承
- size_t,无符号整数，大小随平台决定
- 日志格式：patten{}
- #name,将name当作字符串，相当于为name加上引号，name是字符，并不是自定义的变量
- std::funtion:
- class logger
- (std::get<2>(i) == 0)//获取元组第三个，如 auto i=make_tuple(string,string,int),这个就获取int位置的元素

- shared_ptr自带reset函数
- 在.cc文件声明和定义的类，如果在文件内需要使用,需要把它放到用的地方之前

待填的坑:LogForamtter的init(),过程还没完全看懂

> std::vector<std::tuple<std::string, std::string, int>> vec;：定义了一个存储三元组（包含两个字符串和一个整数）的向量 vec，用于存储解析结果。
size_t last_pos = 0;：定义了一个变量 last_pos，用于保存上一次解析的位置。
std::string nstr;：定义了一个字符串 nstr，用于存储非格式化字符。
for (size_t i = 0; i < m_pattern.size(); ++i)：遍历字符串 m_pattern，进行解析。
if (m_pattern[i] == '%')：如果当前字符是 %，表示可能是格式化项的开始，将 nstr 中的字符和 % 添加到 nstr 中。
if ((i + 1) < m_pattern.size())：判断下一个字符是否存在。
如果下一个字符是 %，表示当前字符是一个普通字符，将 % 添加到 nstr 中。
如果下一个字符不是 %，则进入格式化项的解析逻辑。
进入格式化项解析逻辑：
fmt_status 表示解析状态，0 表示未解析，1 表示解析格式，2 表示解析完成。
fmt_begin 记录格式化项开始的位置。
str 存储格式化项的名称。
fmt 存储格式化项的参数。
解析格式化项的名称和参数，存储到 str 和 fmt 变量中。
根据解析结果构建不同类型的格式化项，并将其存储到 vec 中。
如果 fmt_status 为 0，表示是普通字符串，将其存储到 vec 中。
如果 fmt_status 为 1，表示格式化项解析错误，将错误信息存储到 vec 中。
如果 fmt_status 为 2，表示格式化项解析成功，将格式化项存储到 vec 中。
使用预定义的 std::map s_format_items 构建格式化项的类型映射。
遍历 vec，根据解析结果构建相应的 FormatItem 对象，并存储到 m_items 中。
总的来说，这段代码的目的是将一个字符串模式解析成多个格式化项，每个格式化项都有一个名称和可能的参数，这些格式化项会在日志记录时根据模式进行格式化。这种设计可以让用户自定义日志输出的格式，并且可以支持不同类型的格式化项，比如消息、时间戳、日志级别等。


- **指针函数**定义一个指针函数，只要是满足这个的，都可以用operation=functionName来赋值，然后使用operation(int,int)来调用赋值的函数
> int (*operation)(int, int);

细节提高方面
==============
在编程中，有许多微小的细节和技巧可以用来提高性能。这些优化通常是针对特定的编程语言、编译器或者硬件架构的。以下是一些通用的性能优化技巧：
- 选择适当的数据结构和算法： 选择合适的数据结构和算法可以大幅度提高程序性能。例如，使用哈希表来加速查找操作，使用合适的排序算法来提高排序效率。
- 避免不必要的内存分配和释放： 减少动态内存分配的次数，尽量使用栈上的内存而不是堆上的内存。在C++中，可以使用对象池技术来重复利用已分配的对象，减少内存分配和释放的开销。
- 减少函数调用的开销： 避免过多的函数调用，特别是在循环内部。函数调用通常伴随着栈帧的创建和销毁，可能会带来较大的开销。
- 内联函数（Inline Functions）： 将频繁调用的小函数标记为内联函数，可以减少函数调用的开销。
- 循环优化： 避免循环内部的计算或函数调用，将这些操作提到循环外部。例如，将循环不变式（loop invariant）移到循环外部，减少循环内部的计算次数。
- 位运算优化： 使用位运算替代乘法和除法操作，特别是2的幂次方相关的操作，可以用位运算代替。
- 缓存友好性： 编写缓存友好的代码，尽量使得数据访问更加连续，减少缓存未命中的次数。
多线程和并行编程： 在多核处理器上，通过多线程和并行编程，可以更好地利用硬件资源，提高程序的整体性能。
- 减少I/O操作： 尽量减少文件、网络等I/O操作，可以使用缓冲、异步I/O等技术来优化。
- 编译器优化： 使用合适的编译器优化选项，例如 -O2、-O3 等，以及特定的编译器指令，来帮助编译器生成更高效的机器代码。
