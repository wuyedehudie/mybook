
前缀和
```
target[]={1,2,3,4,5,6}
for (int i = 1; i <= n; ++i) {
        prefix[i] = prefix[i - 1] + target[i - 1];
    }
```

节点a和b的最近公共祖先
没学过算法的话按照朴素思想首先思路是用father[]来记录每一个节点的父节点，然后向上遍历，找到所有祖先直到根节点，然后比对每一个祖先是否有相同的。
第一个优化是用一个deep数组来记录每一个节点的深度，假设a的深度比b小，即a离根节点更近，在这有两种情况，1.a是b的祖先，2.a和b有另外一个祖先。所以用一个临时节点p先从b往上遍历到和a同一个深度，判断p是不是a，如果不是，就直接从此时p和a同时往上找同一高度的祖先，判断是否相同，直到根节点。
第二个优化就是倍增，指构建深度的时候记录每2的倍数
第三个优化是，假如有多个树，而a和b可能不是同一棵树的时候，需要用并查集来判断是不是在同一颗树，就不需要遍历了。