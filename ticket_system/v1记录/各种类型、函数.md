inet_ntop//将ip转为字符串（十进制
```
pcap_t *pcap_open_live(const char *device, int snaplen, int promisc, int to_ms, char *errbuf);
```
device：要打开的网络设备名称，比如 "eth0"、"wlan0" 等。
snaplen：要捕获的数据包的最大长度。通常使用 BUFSIZ，即 #include <stdio.h> BUFSIZ。
promisc：指定是否设置为混杂模式。promisc 为非 0 时表示启用混杂模式，0 表示禁用。
to_ms：设置超时时间（以毫秒为单位），如果没有数据包到达，函数将等待 to_ms 毫秒后超时。
errbuf：存放错误消息的缓冲区。

```
char errbuf[PCAP_ERRBUF_SIZE]; - 声明一个用于存放错误消息的字符数组 errbuf。
pcap_t* handle; - 声明一个 pcap_t 类型的指针 handle，用于表示捕获会话。
const char* dev = "ens33"; - 设置要捕获的网络接口名称。
handle = pcap_open_live(dev, BUFSIZ, 1, 1000, errbuf); - 调用 pcap_open_live 函数，打开名为 dev 的网络接口，设置捕获数据包的最大长度为 BUFSIZ，启用混杂模式（因为第三个参数是 1），设置超时时间为 1000 毫秒。如果失败，错误消息会被存储在 errbuf 中。
if (handle == nullptr) { ... } - 检查 handle 是否为 nullptr，如果是则打印出无法打开设备的错误消息，并返回 1。
struct bpf_program fp; - 声明 bpf_program 结构，它将用于存储过滤器信息。
char filter_exp[] = "tcp"; - 设置过滤器表达式，这里是捕获 TCP 数据包。
if (pcap_compile(handle, &fp, filter_exp, 0, PCAP_NETMASK_UNKNOWN) == -1) { ... } - 调用 pcap_compile 编译过滤器表达式，如果出现错误，打印错误消息，并返回 1。
if (pcap_setfilter(handle, &fp) == -1) { ... } - 调用 pcap_setfilter 设置编译好的过滤器，如果出现错误，打印错误消息，并返回 1。
pcap_loop(handle, 0, packetHandler, nullptr); - 这里是捕获循环，它将持续捕获数据包并对每个数据包调用 packetHandler 函数来处理它。
pcap_close(handle); - 最后，调用 pcap_close 关闭捕获会话。
该代码的主要目的是捕获指定接口的 TCP 数据包，并使用过滤器仅捕获 TCP 数
```

```
//原版存储nicard函数
void NICinfo::getLINUX_NIC() {
        struct ifaddrs *next, *results;

        if (getifaddrs(&results) == -1) {
            perror("getifaddrs");
            exit(EXIT_FAILURE);
        }

        for (next = results; next != nullptr; next = next->ifa_next) {
            if (next->ifa_addr == nullptr) {
                continue;
            }
            if (next->ifa_addr->sa_family == AF_INET) {
                m_storageIPv4 = *reinterpret_cast<sockaddr_storage*>(next->ifa_addr);
                m_IPv4addr = reinterpret_cast<sockaddr_in*>(&m_storageIPv4);

                char ipAddr[INET_ADDRSTRLEN];
                inet_ntop(AF_INET, &(m_IPv4addr->sin_addr), ipAddr, INET_ADDRSTRLEN);
                // 处理 IPv4 地址信息，ipAddr 包含了 IP 地址字符串表示
            } else if (next->ifa_addr->sa_family == AF_INET6) {
                m_storageIPv6 = *reinterpret_cast<sockaddr_storage*>(next->ifa_addr);
                m_IPv6addr = reinterpret_cast<sockaddr_in6*>(&m_storageIPv6);
                // 处理 IPv6 地址信息
            }
        }

        freeifaddrs(results);
    }
```


```
<<sys/socket.h>>    //linux
<Winsock2.h>    //window
struct sockaddr {
    unsigned short    sa_family;    // 地址族，例如 AF_INET、AF_INET6
    char              sa_data[14];  // 地址数据，实际地址信息
};
```
```
#include <netinet/in.h>
struct sockaddr_in {
    short int          sin_family;  // 地址族，例如 AF_INET
    unsigned short int sin_port;    // 端口号，网络字节序
    struct in_addr     sin_addr;    // IPv4地址,里面是一个uint32_t类型
    unsigned char      sin_zero[8]; // 未使用，填充0
};

```
```
<netinet/in.h>  //UNIX/Linux
<Ws2tcpip.h>  //在Windows。
struct sockaddr_in6 {
    u_int16_t       sin6_family;   // 地址族，AF_INET6
    u_int16_t       sin6_port;     // 端口号，网络字节序
    u_int32_t       sin6_flowinfo; // 流信息
    struct in6_addr sin6_addr;     // IPv6地址
    u_int32_t       sin6_scope_id; // 用于标识接口
};
```
