epoll代替了socket的listen, 不需要阻塞等待
timer(fd,fd_address)

```epoll_wait()```返回值是发生了事件的文件描述符数量
m_conn_ = ::mysql_init(nullptr);和m_conn_ = ::mysql_init(m_conn_);的区别: 第二个如果m_conn_是已有的连接对象，则会释放该资源，尽量使用第二种 

### thread_pool
- 依赖sql_connection_pool.h, locker.h
- 构造前需要传入sql_connection_pool对象，其他最大连接数等有默认参数
- sql_connection_pool.h任务：用msyql库的init(),sql_real_connect()初始化多个数据库连接MYSQL *，


事件循环服务器基本流程
```
#include <muduo/net/TcpServer.h>
#include <muduo/net/EventLoop.h>
#include <iostream>

using namespace muduo;
using namespace muduo::net;

class TicketServer {
public:
    TicketServer(EventLoop* loop, const InetAddress& listenAddr)
        : server_(loop, listenAddr, "TicketServer") {
        server_.setConnectionCallback(std::bind(&TicketServer::onConnection, this, _1));
        server_.setMessageCallback(std::bind(&TicketServer::onMessage, this, _1, _2, _3));
    }

    void start() {
        server_.start();
    }

private:
    void onConnection(const TcpConnectionPtr& conn) {
        if (conn->connected()) {
            std::cout << "New connection from " << conn->peerAddress().toIpPort() << std::endl;
        } else {
            std::cout << "Connection " << conn->peerAddress().toIpPort() << " is down" << std::endl;
        }
    }

    void onMessage(const TcpConnectionPtr& conn, Buffer* buf, Timestamp time) {
        std::string message = buf->retrieveAllAsString();
        std::cout << "Received message from " << conn->peerAddress().toIpPort() << ": " << message << std::endl;
        // 在这里处理客户端发送的消息，例如进行车票查询等操作
    }

    TcpServer server_;
};

int main() {
    EventLoop loop;
    InetAddress listenAddr(9876); // 设置服务器监听端口
    TicketServer server(&loop, listenAddr);
    server.start();
    loop.loop();
    return 0;
}
```